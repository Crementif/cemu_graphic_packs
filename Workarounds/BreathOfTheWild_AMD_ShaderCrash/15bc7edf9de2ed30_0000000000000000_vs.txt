#version 420
#extension GL_ARB_texture_gather : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_packing : enable
#ifdef VULKAN
#define ATTR_LAYOUT(__vkSet, __location) layout(set = __vkSet, location = __location)
#define UNIFORM_BUFFER_LAYOUT(__glLocation, __vkSet, __vkLocation) layout(set = __vkSet, binding = __vkLocation, std140)
#define TEXTURE_LAYOUT(__glLocation, __vkSet, __vkLocation) layout(set = __vkSet, binding = __vkLocation)
#define SET_POSITION(_v) gl_Position = _v; gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0
#define GET_FRAGCOORD() vec4(gl_FragCoord.xy*uf_fragCoordScale.xy,gl_FragCoord.zw)
#define gl_VertexID gl_VertexIndex
#define gl_InstanceID gl_InstanceIndex
#else
#define ATTR_LAYOUT(__vkSet, __location) layout(location = __location)
#define UNIFORM_BUFFER_LAYOUT(__glLocation, __vkSet, __vkLocation) layout(binding = __glLocation, std140) 
#define TEXTURE_LAYOUT(__glLocation, __vkSet, __vkLocation) layout(binding = __glLocation)
#define SET_POSITION(_v) gl_Position = _v
#define GET_FRAGCOORD() vec4(gl_FragCoord.xy*uf_fragCoordScale,gl_FragCoord.zw)
#endif
// This shaders was auto-converted from OpenGL to Cemu so expect weird code and possible errors.

// shader 15bc7edf9de2ed30
UNIFORM_BUFFER_LAYOUT(6, 0, 1) 
uniform uniformBlockVS6
{
vec4 uf_blockVS6[1024];
};


UNIFORM_BUFFER_LAYOUT(7, 0, 2) 
uniform uniformBlockVS7
{
vec4 uf_blockVS7[1024];
};


UNIFORM_BUFFER_LAYOUT(8, 0, 3) 
uniform uniformBlockVS8
{
vec4 uf_blockVS8[1024];
};


UNIFORM_BUFFER_LAYOUT(11, 0, 4) 
uniform uniformBlockVS11
{
vec4 uf_blockVS11[1024];
};


TEXTURE_LAYOUT(45, 0, 0) uniform sampler2D textureUnitVS13;
ATTR_LAYOUT(0, 0) in uvec4 attrDataSem0;
ATTR_LAYOUT(0, 1) in uvec4 attrDataSem1;
ATTR_LAYOUT(0, 2) in uvec4 attrDataSem2;
ATTR_LAYOUT(0, 3) in uvec4 attrDataSem3;
ATTR_LAYOUT(0, 4) in uvec4 attrDataSem4;
ATTR_LAYOUT(0, 5) in uvec4 attrDataSem5;
ATTR_LAYOUT(0, 6) in uvec4 attrDataSem6;
ATTR_LAYOUT(0, 7) in uvec4 attrDataSem7;
out gl_PerVertex
{
	vec4 gl_Position;
	float gl_PointSize;
};
int clampFI32(int v)
{
if( v == 0x7FFFFFFF )
	return floatBitsToInt(1.0);
else if( v == 0xFFFFFFFF )
	return floatBitsToInt(0.0);
return floatBitsToInt(clamp(intBitsToFloat(v), 0.0, 1.0));
}
float mul_nonIEEE(float a, float b){ return min(a*b,min(abs(a)*3.40282347E+38F,abs(b)*3.40282347E+38F)); }
void main()
{
// export
SET_POSITION(vec4(0.0));
}
